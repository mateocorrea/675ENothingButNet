#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           topLeftLauncher, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port3,           bottomLeftLauncher, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           topRightLauncher, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           bottomRightLauncher, tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard          !!*//
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    An example of flywheel/shooter velocity control using the TBH algorithm  */
/*    Test system uses three motors with 25:2 gearing to the flywheel.         */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              25

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_393S          392

// Structure to gather all the flywheel related data
typedef struct _fw_controller {
    long            counter;                ///< loop counter used for debug

    // encoder tick per revolution
    float           ticks_per_rev;          ///< encoder ticks per revolution

    // Encoder
    long            e_current_left;              ///< current encoder count
    long            e_current_right;
    long            e_last_left;                 ///< current encoder count
    long            e_last_right;

    // velocity measurement
    float           v_current_left;              ///< current velocity in rpm
    float           v_current_right;
    long            v_time;                 ///< Time of last velocity calculation

    // TBH control algorithm variables
    long            target;                 ///< target velocity
    long            current_left;                ///< current velocity
    long            current_right;
    long            last_left;                   ///< last velocity
    long            last_right;
    float           error_left;                  ///< error between actual and target velocities
    float           error_right;
    float           last_error_left;             ///< error last time update called
    float           last_error_right;
    float           gain_left;                   ///< gain
    float           gain_right;
    float           drive_left;                  ///< final drive out of TBH (0.0 to 1.0)
    float           drive_right;
    float           drive_at_zero_left;          ///< drive at last zero crossing
    float           drive_at_zero_right;
    long            first_cross_left;            ///< flag indicating first zero crossing
    long            first_cross_right;
    float           drive_approx;           ///< estimated open loop drive

    // final motor drive
    long            motor_drive_left;            ///< final motor control value
    long            motor_drive_right;
    } fw_controller;

// Make the controller global for easy debugging
static  fw_controller   flywheel;

/*-----------------------------------------------------------------------------*/
/** @brief      Set the flywheen motors                                        */
/** @param[in]  value motor control value                                      */
/*-----------------------------------------------------------------------------*/
void FwMotorSetLeft( int value )
{
	motor[topRightLauncher] = value;
    motor[bottomRightLauncher] = value;
}
void FwMotorSetRight( int value )
{
	motor[topLeftLauncher] = value;
  motor[bottomLeftLauncher] = value;

}

/*-----------------------------------------------------------------------------*/
/** @brief      Get the flywheen motor encoder count                           */
/*-----------------------------------------------------------------------------*/
long FwMotorEncoderGetLeft()
{
    return( nMotorEncoder[ topRightLauncher ] );
}

long FwMotorEncoderGetRight()
{
    return ( nMotorEncoder[ topLeftLauncher ]);
}

/*-----------------------------------------------------------------------------*/
/** @brief      Set the controller position                                    */
/** @param[in]  fw pointer to flywheel controller structure                    */
/** @param[in]  desired velocity                                               */
/** @param[in]  predicted_drive estimated open loop motor drive                */
/*-----------------------------------------------------------------------------*/
void FwVelocitySet( fw_controller *fw, int velocity, float predicted_drive )
{
    // set target velocity (motor rpm)
    fw->target        = velocity;

    // Set error so zero crossing is correctly detected
    fw->error_left         = fw->target - fw->current_left;
    fw->error_right        = fw->target - fw->current_right;
    fw->last_error_left    = fw->error_left;
    fw->last_error_right   = fw->error_right;

    // Set predicted open loop drive value
    fw->drive_approx  = predicted_drive;
    // Set flag to detect first zero crossing
    fw->first_cross_left   = 1;
    fw->first_cross_right  = 1;
    // clear tbh variable
    fw->drive_at_zero_left = 0;
    fw->drive_at_zero_right = 0;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Calculate the current flywheel motor velocity                  */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void FwCalculateSpeed( fw_controller *fw )
{
    int     delta_ms;
    int     delta_enc_left;
    int     delta_enc_right;

    // Get current encoder value
    fw->e_current_left = FwMotorEncoderGetLeft();
    fw->e_current_right = FwMotorEncoderGetRight();

    // This is just used so we don't need to know how often we are called
    // how many mS since we were last here
    delta_ms   = nSysTime - fw->v_time;
    fw->v_time = nSysTime;

    // Change in encoder count
    delta_enc_left = (fw->e_current_left - fw->e_last_left);
    delta_enc_right = (fw->e_current_right - fw->e_last_right);

    // save last position
    fw->e_last_left = fw->e_current_left;
    fw->e_last_right = fw->e_current_right;

    // Calculate velocity in rpm
    fw->v_current_left = (1000.0 / delta_ms) * delta_enc_left * 60.0 / fw->ticks_per_rev;
    fw->v_current_right = (1000.0 / delta_ms) * delta_enc_right * 60.0 / fw->ticks_per_rev;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Update the velocity tbh controller variables                   */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void FwControlUpdateVelocityTbh( fw_controller *fw )
{
    // calculate error in velocity
    // target is desired velocity
    // current is measured velocity
    fw->error_left = fw->target - fw->current_left;
    fw->error_right = fw->target - fw->current_right;

    // Use Kp as gain
    fw->drive_left =  fw->drive_left + (fw->error_left * fw->gain_left);
    fw->drive_right = fw->drive_right + (fw->error_right * fw->gain_right);

    // Clip - we are only going forwards
    if( fw->drive_left > 1 )
          fw->drive_left = 1;
    if( fw->drive_left < 0 )
          fw->drive_left = 0;
    if( fw->drive_right > 1 )
          fw->drive_right = 1;
    if( fw->drive_right < 0 )
          fw->drive_right = 0;

    // Check for zero crossing
    if( sgn(fw->error_left) != sgn(fw->last_error_left) ) {
        // First zero crossing after a new set velocity command
        if( fw->first_cross_left ) {
            // Set drive to the open loop approximation
            fw->drive_left = fw->drive_approx;
            fw->first_cross_left = 0;
        }
        else
            fw->drive_left = 0.5 * ( fw->drive_left + fw->drive_at_zero_left );

        // Save this drive value in the "tbh" variable
        fw->drive_at_zero_left = fw->drive_left;
    }
    if( sgn(fw->error_right) != sgn(fw->last_error_right) ) {
        // First zero crossing after a new set velocity command
        if( fw->first_cross_right ) {
            // Set drive to the open loop approximation
            fw->drive_right = fw->drive_approx;
            fw->first_cross_right = 0;
        }
        else
            fw->drive_right = 0.5 * ( fw->drive_right + fw->drive_at_zero_right );

        // Save this drive value in the "tbh" variable
        fw->drive_at_zero_right = fw->drive_right;
    }

    // Save last error
    fw->last_error_left = fw->error_left;
    fw->last_error_right = fw->error_right;
}

/*-----------------------------------------------------------------------------*/
/** @brief     Task to control the velocity of the flywheel                    */
/*-----------------------------------------------------------------------------*/
task FwControlTask()
{
    fw_controller *fw = &flywheel;

    // Set the gain
    fw->gain_left = 0.00030;//0.00025;
    fw->gain_right = fw->gain_left;

    // We are using Speed geared motors
    // Set the encoder ticks per revolution
    fw->ticks_per_rev = MOTOR_TPR_393S;

    while(1)
        {
        // debug counter
        fw->counter++;

        // Calculate velocity
        FwCalculateSpeed( fw );

        // Set current speed for the tbh calculation code
        fw->current_left = fw->v_current_left;
        fw->current_right = fw->v_current_right;

        // Do the velocity TBH calculations
        FwControlUpdateVelocityTbh( fw ) ;

        // Scale drive into the range the motors need
        fw->motor_drive_left  = (fw->drive_left * FW_MAX_POWER) + 0.5;
        fw->motor_drive_right = (fw->drive_right * FW_MAX_POWER) + 0.5;

        // Final Limit of motor values - don't really need this
        if( fw->motor_drive_left >  127 ) fw->motor_drive_left =  127;
        if( fw->motor_drive_left < -127 ) fw->motor_drive_left = -127;
        if( fw->motor_drive_right >  127 ) fw->motor_drive_right =  127;
        if( fw->motor_drive_right < -127 ) fw->motor_drive_right = -127;

        // and finally set the motor control value
        FwMotorSetLeft( fw->motor_drive_left );
        FwMotorSetRight( fw->motor_drive_right );

        // Run at somewhere between 20 and 50mS
        wait1Msec( FW_LOOP_SPEED );
        }
}

// Main user task
task tbh()
{
    char  str[32];

    bLCDBacklight = true;

    // Start the flywheel control task
    startTask( FwControlTask );

    // Main user control loop
    while(1)
        {
        // Different speeds set by buttons
        // (flywheel, velocity, predicted drive)
        if( vexRT[ Btn8L ] == 1 )
            FwVelocitySet( &flywheel, 149, 0.55 );
        if( vexRT[ Btn8U ] == 1 )
            FwVelocitySet( &flywheel, 120, 0.38 );
        if( vexRT[ Btn8R ] == 1 )
            FwVelocitySet( &flywheel, 50, 0.2 );
        if( vexRT[ Btn8D ] == 1 )
            FwVelocitySet( &flywheel, 00, 0 );

        // Display useful things on the LCD
        sprintf( str, "%4d %4d  %5.2f", flywheel.target,  flywheel.current_left, nImmediateBatteryLevel/1000.0 );
        displayLCDString(0, 0, str );
        sprintf( str, "%4.2f %4.2f ", flywheel.drive_left, flywheel.drive_at_zero_left );
        displayLCDString(1, 0, str );

        // Don't hog the cpu :)
        wait1Msec(10);
        }
}
